---
title: "Scraping lyrics data from vagalume.com"
author: "Anderson Neisse"
date: 2019-02-10
categories: ["Web Scraping"]
tags: ["Web Scraping", "Music"]
header:
  caption: ''
  image: ''
output: 
  html_document:
    code_folding: show
---



<p>Today I woke up with a desire to stretch my web scraping skills and willing to do so while listening to some music, so why not scrap some music data? In this post I will scrap som data on artists and their lyrics so in a future post I plan on having some visualizations on the data as well as train a LSTM on the lyrics and maybe make it compose some new ones!</p>
<p>This whole post is about scraping the data from a Brazilian lyrics website called <a href="https://www.vagalume.com.br">Vagalume</a> (literally Firefly in PT-BR), which stores music lyrics for a lot of artists, not only Brazilians. The site’s evaluations of popularity might result on some cool visualizations. And of course, it’s accessed almost exclusively by brazilians, so it will be informative about their tastes, on some level.</p>
<p>NOTE: The datasets generated by this posts are stored in Kaggle <a href="http://www.kaggle.com/neisse/scrapped-lyrics-from-6-genres">here</a>, in case you want them to do some analysis.</p>
<p>Some packages we will need for this task:</p>
<pre class="r"><code>library(tidyverse)
library(httr)
library(xml2)
library(rvest)
library(furrr)</code></pre>
<p>The packages <code>httr</code>, <code>xml2</code> and <code>rvest</code> are the main ones for html-based web scraping these days. Loading <code>tidyverse</code> for all reasons and <code>furrr</code> for combination of <code>future</code> and <code>purrr</code> packages.</p>
<p>The website has a A-to-Z list of artists, with a link for each letter, then a link for each artist with such starting letter, which contains a list of music names with lyrics “inside”. It also displays the artists in music genre sections, which I will use, they work very similarly to the A-to-Z sections. I’ll need to go through lots of links in order to collect all the data I want.</p>
<div id="scraping-artists-data" class="section level1">
<h1>1 Scraping artists data</h1>
<p>First let’s grab data on the artists, it’s a first step to know how many artists and musics the site has. At the end of this section we should have a data frame containing data on the artists on the website.</p>
<p>To obtain our data frame we will need a list of links to artists’ pages on the site as well as a scrapper function to return the data we want from them. The scrapper is the function that will receive a link a an artist’s page and return the data we want. Using the <code>rvest</code> package we can build a scrapper.</p>
<p>Let’s first build a scrapper that returns the data we need from a single artist. For that purpose I’m going to use the page for <a href="https://www.vagalume.com.br/green-day/">Green Day</a>.</p>
<p>We can see that it contains the bands name, the list of all the lyrics, and a subpage “Popularidade” with the popularity history of the band according to the site’s access history. Those pages are constant across all the artists while the others aren’t as some artists might not have them. Now, there are some information that we can get for individual artists:</p>
<ul>
<li>Artist’s name;</li>
<li>Genre labels;</li>
<li>Number of musics in the site;</li>
<li>Popularity;</li>
</ul>
<p>Let’s get scraping!</p>
<div id="building-the-scrapper" class="section level2">
<h2>Building the scrapper</h2>
<p>I’m going to start with scraping the band’s name to illustrate how <code>rvest</code> works with web scraping. The code below does that job for us. The <code>read_html()</code> parses a html page into R. Then, <code>html_nodes()</code> extracts a specific part (node) from the page that contains the data we want. You can define the node’s name with <a href="https://selectorgadget.com/">Selector Gadget</a> or by inspecting the page’s code in the browser. Also, a fun and very instructive tutorial on selecting css labels is <a href="http://flukeout.github.io/#">CSS Dinner</a>. Finally, we turn the lyric into text, removing line breaks and this sort of stuff with <code>html_text</code>.</p>
<pre class="r"><code># Getting an artists name
read_html(&quot;https://www.vagalume.com.br/green-day/&quot;) %&gt;% html_nodes(&quot;.darkBG&quot;) %&gt;% html_text()</code></pre>
<pre><code>## [1] &quot;Green Day&quot;</code></pre>
<p>There, now we will try to get the labels for music genre for the band:</p>
<pre class="r"><code># Scraping data on genre
read_html(&quot;https://www.vagalume.com.br/green-day/&quot;) %&gt;% html_nodes(&quot;.subHeaderTags&quot;) %&gt;% 
  as_list() %&gt;% unlist() %&gt;% paste(collapse = &quot;; &quot;)</code></pre>
<pre><code>## [1] &quot;Rock; Punk Rock; Rock Alternativo&quot;</code></pre>
<p>In this case we need to parse it to a list using <code>xml2::as_list()</code> and then use <code>apply::unlist()</code> in order to transform the html to a vector. If we used <code>rvest::html_text()</code> it would have concatenated all the labels with <code>sep = ""</code>. Green day has the labels: “Rock”; “Punk Rock” and “Rock Alternativo” (Alternative Rock).</p>
<p>Now let’s try and get number of musics for the band. The main page for them has the list of all their songs, we can get them and them store their count.</p>
<pre class="r"><code>read_html(&quot;https://www.vagalume.com.br/green-day/&quot;) %&gt;% html_nodes(&quot;.nameMusic&quot;) %&gt;% html_text() %&gt;% 
  unique() %&gt;% length()</code></pre>
<pre><code>## [1] 239</code></pre>
<p>The first line of code above, if ran alone, returns a vector with all the music names in the page. However before the list of all songs there is a top 25 of the artist’s songs, so we remove duplicates by using <code>unique()</code> and then count how many songs are there using <code>length()</code> applied to the resulting vector of unique song names.</p>
<p>Now, last but not least important, the artist’s popularity. This one is stored in a sub-page (\popularidade\) of each artist. In the end of the page it shows the current popularity in a pop which always begins with the word “Atualmente”.</p>
<pre class="r"><code>read_html(&quot;https://www.vagalume.com.br/green-day/popularidade/&quot;) %&gt;% html_nodes(&quot;.text&quot;) %&gt;% html_text()</code></pre>
<pre><code>## [1] &quot;A primeira vez que Green Day apareceu no Vagalume foi em Junho de 2003.As 2 músicas mais acessadas na época eram Basket Case e When I Come Around.&quot;                                                              
## [2] &quot;Nos meses de Março e Maio de 2005, Green Day ganhou popularidade com a música Boulevard Of Broken Dreams.\nNo período, a popularidade máxima atingiu 150,0 pontos em Março.&quot;                                     
## [3] &quot;Por 5 meses, entre Setembro de 2005 e Fevereiro de 2006, Green Day ganhou popularidade com a música Wake Me Up When September Ends.\nNo período, a popularidade máxima atingiu 178,0 pontos em Novembro de 2005.&quot;
## [4] &quot;Atualmente, em Setembro de 2018, a popularidade está em 9,0 pontos e a música mais acessada é Wake Me Up When September Ends.&quot;</code></pre>
<p>So we need to filter the one that begins with that word (which means ‘Currently’ by the way). And then we need to extract the value of popularity (9.0 in this case) which is always in between the words “em” and “pontos”.</p>
<pre class="r"><code>read_html(&quot;https://www.vagalume.com.br/green-day/popularidade/&quot;) %&gt;% html_nodes(&quot;.text&quot;) %&gt;% html_text() %&gt;% 
  tail(1) %&gt;% # Extracting last phrase
  str_extract(., &quot;(?&lt;=está em )(.*)(?= pontos)&quot;) %&gt;% # Using Regular Expressions to remove the number
  str_replace(&quot;,&quot;, &quot;.&quot;) %&gt;% as.numeric() # Replacing brazilian decimal &quot;,&quot; by &quot;.&quot; and arsing to numeric</code></pre>
<pre><code>## [1] 9</code></pre>
<p>It took some work but we got the popularity for the band, shame it’s rounded up to an integer, but it won’t be completely useless.</p>
<p>Now we know how to get every information we need from a single artist, so let’s build our scraper function:</p>
<pre class="r"><code>scrap_artist &lt;- function(artist_link){
  # Reading the entire pages
  page &lt;- read_html(paste0(&quot;https://www.vagalume.com.br&quot;, artist_link))
  pop_page &lt;- read_html(paste0(&quot;https://www.vagalume.com.br&quot;, artist_link, &quot;popularidade/&quot;))
  
  # Getting desired variables
  A &lt;- page %&gt;% html_nodes(&quot;.darkBG&quot;) %&gt;% html_text()
    
  G &lt;- page %&gt;% html_nodes(&quot;.subHeaderTags&quot;) %&gt;% 
    as_list() %&gt;% unlist() %&gt;% paste(collapse = &quot;; &quot;)
  
  S &lt;- page %&gt;% html_nodes(&quot;.nameMusic&quot;) %&gt;% html_text() %&gt;% 
  unique() %&gt;% length()
  
  P &lt;- pop_page %&gt;% html_nodes(&quot;.text&quot;) %&gt;% html_text() %&gt;% 
    tail(1) %&gt;% 
    str_extract(., &quot;(?&lt;=está em )(.*)(?= pontos)&quot;) %&gt;% 
    str_replace(&quot;,&quot;, &quot;.&quot;) %&gt;% as.numeric() 
  
  # Creating tibble
  res &lt;- tibble(Artist = A, Genres = G, Songs = S, Popularity = P, Link = artist_link)
  return(res)
}

# Testing the scrapper function
scrap_artist(&quot;/green-day/&quot;)</code></pre>
<pre><code>## # A tibble: 1 x 5
##   Artist    Genres                            Songs Popularity Link       
##   &lt;chr&gt;     &lt;chr&gt;                             &lt;int&gt;      &lt;dbl&gt; &lt;chr&gt;      
## 1 Green Day Rock; Punk Rock; Rock Alternativo   239          9 /green-day/</code></pre>
<p>Nice, a single function that receives a link to an artist and returns all the data we defined for that artist. Notice that I defined a function such as it receives only the important part of the link, which is what we will scrap from the site in order to form our data frame.</p>
</div>
<div id="obtaining-links-of-artists" class="section level2">
<h2>Obtaining links of artists</h2>
<p>Now, since this post is just to stretch my web scraping skills and have some fun I won’t scrap data from all the artists, which could take ages as the process depends not only on the processing power but also on the internet connection and time to get to each link. However, we will get some music genres to play:</p>
<ul>
<li>Rock</li>
<li>Hip Hop</li>
<li>Pop music</li>
<li>Sertanejo (Basically the Brazilian version of Country Music)</li>
<li>Funk Carioca (Originated 60s US Funk, a completely different genre in Brazil nowadays)</li>
<li>Samba (Typical Brazilian music)</li>
</ul>
<p>In order to map our scrapper to artists we need to have the link to their pages in the website. For that we need to get the links for music genre sections we want to scrap:</p>
<pre class="r"><code>section_links &lt;- c(&quot;/browse/style/rock.html&quot;, 
                   &quot;/browse/style/hip-hop.html&quot;,
                   &quot;/browse/style/pop.html&quot;, 
                   &quot;/browse/style/sertanejo.html&quot;, 
                   &quot;/browse/style/funk-carioca.html&quot;, 
                   &quot;/browse/style/samba.html&quot;)</code></pre>
<p>Now, in one specific page (“Rock”), we need to figure out how to get the list of artists. We need to do it since we will need a list of all the artists to scrap the data with the <code>scrap_artist</code> function. Let’s start by getting the objects with <code>class=moreNamesContainer</code> (“.moreNamesContainer”) as identified in the page’s code with .</p>
<p>The table containing all the names for each section page is converted to a list (which unfortunately has 4 levels), so the code below is able to extract the links. It’s already inside a function <code>artist_links</code> that will be useful for us.</p>
<pre class="r"><code>get_artist_links &lt;- function(section_link){
  # Reading the page
  page &lt;- read_html(paste0(&quot;https://www.vagalume.com.br&quot;, section_link))
  
  # Removing desired node as a list
  nameList &lt;- page %&gt;% html_nodes(&quot;.moreNamesContainer&quot;) %&gt;% as_list()
  
  # Removing undesired list levels and extracting &#39;href&#39; attribute
  # &#39;NOT ELEGANT AT ALL&#39; ALLERT
  artist_links &lt;- nameList %&gt;% 
    unlist(recursive = F) %&gt;% # Removing first undesired level
    unlist(recursive = F) %&gt;% # Removing second undesired level
    unlist(recursive = F) %&gt;% # Removig third undesired level, ugh
    map(., ~attr(., &quot;href&quot;)) %&gt;% # Mapping through list to extract attrs
    unlist() %&gt;% as.character() # Removing names and parsing to a vector
  
  return(unique(artist_links))
}

get_artist_links(section_link = &quot;/browse/style/rock.html&quot;) %&gt;% head(10)</code></pre>
<pre><code>##  [1] &quot;/10000-maniacs/&quot;     &quot;/12-stones/&quot;         &quot;/3-doors-down/&quot;     
##  [4] &quot;/311/&quot;               &quot;/4-non-blondes/&quot;     &quot;/4seres/&quot;           
##  [7] &quot;/a-corte-animal/&quot;    &quot;/a-cruz-esta-vazia/&quot; &quot;/a-day-to-remember/&quot;
## [10] &quot;/a-volta/&quot;</code></pre>
<p>Ouch, what inelegant code, probably due to my lack of knowledge on <code>purrr</code>, I definitely need to get deeper than <code>map_*()</code> on this package soon. But ok, let’s map it through all values of <code>section_links</code> in order to obtain the links to all artists in the website.</p>
<p>In order to increase performance we will use <code>furrr::future_map()</code> which is a function that conveniently combines <code>purrr::map()</code> with the parallel processing provided by the <code>future</code> package.</p>
<pre class="r"><code># Planning parallel processing
plan(multisession)

# Getting all artists&#39; links from the website
#all_artists_links &lt;- get_artist_links(&quot;/browse/style/sertanejo.html&quot;)
all_artists_links &lt;- future_map(section_links, ~get_artist_links(.)) %&gt;% unlist()</code></pre>
<p>I got <span class="math inline">\(3.255\)</span> links when I scrapped the data in February 10th in 2019. That leads us to the first big step in this endeavour, our Artists dataset.</p>
</div>
<div id="building-the-dataset" class="section level2">
<h2>Building the dataset</h2>
<p>Now that we have the scrapper function <code>scrap_artist</code> and a list to map it through, we can build our dataset. Since our scrapper returns a tibble i will use the <code>map_dfr</code> variation which already binds the resulting data frames by rows. Of course there is a <code>furrr::future_map_dfr()</code> to save is since this operation is going to be much more demanding than the last one.</p>
<pre class="r"><code># De
p_scrap_artist &lt;- possibly(scrap_artist, 
                           otherwise = tibble(Artist = NA, 
                                              Genres = NA, 
                                              Songs = NA, 
                                              Popularity = NA, 
                                              Link = NA))

# Planning parallel processing
plan(multisession)

# Getting all artists&#39; links from the website
all_artists &lt;- future_map_dfr(all_artists_links, ~p_scrap_artist(.))</code></pre>
<p>It took around 16 minutes to finish this data scraping on my gaming laptop, it may depend on internet connection and processing power. Notice that I used <code>possibly()</code> to create a new function. It wraps a function and in case it returns an error it won’t stop our code, instead it will return what I passed to the <code>otherwise</code> argument, which is a tibble of <code>NA</code>s. It’s possible to use the argument <code>.progress = TRUE</code> in the <code>future_map_*</code> functions in order to check the map procedure progress in case of big operations like this one.</p>
<p>One last thing for us to unify the genres, I want to maintain only the ones we need:</p>
<pre class="r"><code># Selecting genre labels to keep
genres_keep &lt;- c(&quot;Rock&quot;, &quot;Hip Hop&quot;, &quot;Pop&quot;, &quot;Sertanejo&quot;, &quot;Funk Carioca&quot;, &quot;Samba&quot;)


# Removing other genre labels
all_artists_fixed &lt;- all_artists %&gt;% 
  separate(Genres, c(&quot;G1&quot;, &quot;G2&quot;, &quot;G3&quot;), sep = &quot;; &quot;) %&gt;%  # Separating Genres variable
  gather(G1:G3, key = &quot;G&quot;, value = &quot;Genre&quot;) %&gt;% select(-G) %&gt;% 
  filter(Genre %in% genres_keep)</code></pre>
<p>There, now we have some data on all artists on the Genres I specified. The number of rows grew up to <span class="math inline">\(3622\)</span> because of artists that had more than one label, I will rather maintain it this way since removing the duplicates might bias the results to one genre, at least this way the artists weight equally both genres they are present in. The dataset on artists is built! We can do a last step on the data scraping before we stop for today: Scraping their lyrics!</p>
</div>
</div>
<div id="scraping-lyrics-data" class="section level1">
<h1>2 Scraping lyrics data</h1>
<p>I decided to already scrap some data on the lyrics to use in the future analysis post, some text analysis, maybe some sentiment analysis and then I have plans for a lyrics-composing AI, I will create a little monster that will ruin the music industry, ok I’ll stop dreaming. Let’s do it!</p>
<div id="building-the-scrapper-1" class="section level2">
<h2>Building the scrapper</h2>
<p>We are going to do it similarly to how we did it with the artists: do a scrapper to get all the individual links then map throuhg it. I already built a lyrics scraper <code>get_lyric()</code>, that returns the lyric based on the songs’ link. the code below defines it:</p>
<pre class="r"><code># Extracts a single lyric from a song link
get_lyric &lt;- function(song_link){
  
  # Reading the html page
  lyric &lt;- read_html(paste0(&quot;https://www.vagalume.com.br&quot;, song_link)) %&gt;% html_nodes(&quot;#lyrics&quot;)
  
  # Creating sep to replace linebreaks with &quot;. &quot;
  dummy &lt;- xml_node(read_xml(&quot;&lt;doc&gt;&lt;span&gt;. &lt;/span&gt;&lt;/doc&gt;&quot;), &quot;span&quot;)

  # Replacing line-breaks
  xml_add_sibling(xml_nodes(lyric, &quot;br&quot;), dummy)
  
  res &lt;- lyric %&gt;% html_text()
  
  return(res)
}

# Testing it on Holiday from Green Day
get_lyric(&quot;/green-day/holiday.html&quot;)</code></pre>
<pre><code>## [1] &quot;Hear the sound of the falling rain. Coming down like an Armageddon flame (HEY!). The shame, the ones who died without a name. . Hear the dogs howling out of key. To a hymn called \&quot;Faith and Misery\&quot; (Hey!). And bleed, the company lost the war today. . I beg to dream and differ from the hollow lies. This is the dawning of the rest of our lives. On holiday. . Hear the drum pounding out of time. Another protestor has crossed the line (HEY!). To find, the money&#39;s on the other side. . Can I get another Amen (AMEN!). There&#39;s a flag wrapped around a score of men (HEY!). A gag, A plastic bag on a monument. . I beg to dream and differ from the hollow lies. This is the dawning of the rest of our lives. On holiday. . The representative from California has the floor. . Zieg Heil to the president gasman. Bombs away is your punishment. Pulverize the Eiffel towers. Who criticize your government. Bang bang goes the broken glass. Kill all the fags that don&#39;t agree. Trials by fire, setting fire. Is not a way that&#39;s meant for me. Just cause...(hey, hey). Just cause, because we&#39;re outlaws YEAH!. . I beg to dream and differ from the hollow lies. This is the dawning of the rest of our lives. I beg to dream and differ from the hollow lies. This is the dawning of the rest of our lives. This is our lives on holiday&quot;</code></pre>
<p>From this specific lyric we can see that there are still some special characters. Instead of just treating this “\” issue, I’ll remove all special characters when analyzing the lyrics. Better, right? Let’s get to the next step on our scraping adventure.</p>
</div>
<div id="links-to-scrap-the-data-from" class="section level2">
<h2>Links to scrap the data from</h2>
<p>Now we need the list of songs to map the scraper through. The code below defines <code>get_lyrics_links()</code>, which receives the link to the artist then returns a tibble with name and link to the music. It also returns the link to the artist that was passed, in order to use it as an ID for the artist dataset in the future.</p>
<pre class="r"><code># Extracts all lyrics from an artist link - uses get_lyric()
get_lyrics_links &lt;- function(artist_link){
  
  # Reading the html page on the artist
  page &lt;- read_html(paste0(&quot;https://www.vagalume.com.br&quot;, artist_link))
  
  # Obtaining all the musics&#39; links -
  music_name_node &lt;- page %&gt;% html_nodes(&quot;.nameMusic&quot;)
  music_names &lt;- music_name_node %&gt;% html_text()
  music_links &lt;- music_name_node %&gt;% html_attr(&quot;href&quot;)
  
  # Building final tibble
  res &lt;- tibble(ALink = rep(artist_link, length(music_names)),
                SName = music_names,
                SLink = music_links)
  
  return(res)
}

# Testing final function
get_lyrics_links(&quot;/green-day/&quot;) %&gt;% head(5)</code></pre>
<pre><code>## # A tibble: 5 x 3
##   ALink      SName                     SLink                               
##   &lt;chr&gt;      &lt;chr&gt;                     &lt;chr&gt;                               
## 1 /green-da~ Boulevard Of Broken Drea~ /green-day/boulevard-of-broken-drea~
## 2 /green-da~ Good Riddance (Time Of Y~ /green-day/good-riddance-time-of-yo~
## 3 /green-da~ Holiday                   /green-day/holiday.html             
## 4 /green-da~ Wake Me Up When Septembe~ /green-day/wake-me-up-when-septembe~
## 5 /green-da~ Basket Case               /green-day/basket-case.html</code></pre>
<p>Notice that I use <code>html_attr("href")</code> to extract the attribute “href” from the html object, which is the link to the song page. Let’s map this function through all the artists we have in order to obtain the links to the musics:</p>
<pre class="r"><code># Generating safe version of get_lyrics_links()
p_get_lyrics_links &lt;- possibly(get_lyrics_links, 
                               otherwise = tibble(ALink = NA,
                                                  SName = NA))

# Returning all the links to the musics
plan(multisession)
all_songs_links &lt;- future_map_dfr(all_artists_links, ~p_get_lyrics_links(.))</code></pre>
<p>After a 82.98 seconds wait on my case we found out that there are <span class="math inline">\(209.522\)</span> songs for our <span class="math inline">\(3.355\)</span> artists.</p>
</div>
<div id="building-the-lyrics-dataset" class="section level2">
<h2>Building the lyrics dataset</h2>
<p>Now all we gotta do is map hour scraper <code>get_lyric()</code> through all this songs to get our final lyrics dataset.</p>
<pre class="r"><code># Gerenating a safe version with possibly()
p_get_lyric &lt;- possibly(get_lyric, otherwise = NA)

# Mapping it through the all_artists_links vector
plan(multisession)
all_lyrics &lt;- future_map_chr(all_songs_links$SLink, ~p_get_lyric(.)[1], .progress = TRUE)

# Adding it to the dataframe
all_songs_links$Lyric &lt;- all_lyrics %&gt;% str_replace_all(&quot;\\. \\. &quot;, &quot;. &quot;)</code></pre>
<p>This one took around 9,064.08 seconds (151 minutes) to finish, quite some time!</p>
<p>You might be asking why not build a single function to scrap the lyrics. Well, I tried it at first, a function that took the artist link, mapped through all song link inside it and returned a tibble with all the artist lyrics. But it was taking hours to run iterally. I think it happens because <code>furrr</code> can’t optimize well functions that move great pieces of data around. Also, it was a function with a map call inside, seems like it’s not possible to call a future within a future call so I had to separate them in order to optimize running time.</p>
</div>
</div>
<div id="thats-it" class="section level1">
<h1>3 That’s it!</h1>
<p>Both datasets can be foun on my Kaggle datasets page, here. Feel free to analyze it the way you want!</p>
<p>This post is the first of two parts of the music analysis. In the next one i plan on briefly analyzing this data and training a LSTM in the lyrics for each genre. I hope you liked it so far! If you have any feedback on your mind, share it in my twitter <a href="https://twitter.com/a_neisse">@a_neisse</a> or on the contact section of this website.</p>
<style>
body {
text-align: justify}
</style>
</div>
